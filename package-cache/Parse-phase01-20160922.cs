'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 22 September 2016 at 3:42:47.980498 pm'!Object subclass: #IDE4PLCParsers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Parse'!Object subclass: #PLC_ConnectableBlocksNetwork	instanceVariableNames: 'pouBody networkController networkLabel blocks'	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-MVC'!Object subclass: #BasicParsers	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IDE4PLC-Parse'!!PLC_ConnectableBlocksNetwork methodsFor: 'commands add-remove Elements' stamp: 'CarlosLombardi 9/22/2016 11:47'!changeActualArgumentFor: aPLC_ConnectableBlock by: aString	"Cambia el Actual Argument. "	"HACER: 		1 - le pase el string a su pou para que lo convierta en un objeto operando ( PARSEO )		| operand |		Devuelve un objeto que puede ser operando: variable, item de estructura, literal, o void;	o devolver nil si el string es cualquier otra cosa.		operand := self pouBody pou convertStringToOperand: aString		2a - Si es operando, le pido al elemento actual argument del bc que le llega como parametro	que cheque si le cabe que le asignen el operando. 	Este operando seguro entiende dataType y dataValue. 	Si es variable o item de estructura además se puede buscar su declaración 		Si le cabe se pone el flag de 'valorInvalido' a False en el actual argument 		Si no le cabe se pone el flag de 'valorInvalido' a True en el actual argument 			Siempre se lo asigna (cambia el texto auque se ingrese cualquier verdura), 			con el flag se determina si se dibuja en rojo o negro para indicar que se 			va a poder compilar o no.		2b - Si es nil le guarda un operando void al elemento actual argument.						LO DE ABAJO ES UN PARCHE PARA QUE SIGA ANDANDO, DESPUES HAY QUE SACAR TODO....	"			| argument |		"UPDATE 22/09/2016 - nuevo parser más bonito, que usa PetitParser."	argument := self parse: aString.			"Cambia el argumento actual"	aPLC_ConnectableBlock element actualArgument: argument.		^ true.! !!PLC_ConnectableBlocksNetwork methodsFor: 'PARSER' stamp: 'CarlosLombardi 9/22/2016 09:58'!oldParse: aString	"PARSEO LO QUE LLEGUE ASI BUSCO LA VARIABLE CORRECTA"	"aString Parseado pedorramente - Es true, false o numero 	(entero o time)"		| pouDecls decl  argument |		pouDecls := self pouBody pou declarations.			decl := pouDecls includeVarDeclWithIdentifier: aString.		decl 		ifNil: [			"No encontro declaracion. Chequeo si puedo convertir aString 			a un literal, sino creo una nueva variable de la galera con ese			identifier."						"Parseo de Literales barato"							"Pruebo si el string es TRUE"				( aString asLowercase = 'true' )				ifTrue: [					"Si era true creo un Literal true"					argument := ( PLC_Literal 						newWithDataType: PLC_DataType Bool						andDataValue: true	).				]				ifFalse: [					"Pruebo si el string es FALSE"					( aString asLowercase = 'false' )						ifTrue: [ 							"Si era false creo un Literal false"							argument := ( PLC_Literal 								newWithDataType: PLC_DataType Bool								andDataValue: false ).						]						ifFalse: [ 							"Pruebo si es numerico ENTERO"							aString isAllDigits								ifTrue: [ 									"Si era numero creo un Literal INT"									argument := ( PLC_Literal 										newWithDataType: PLC_DataType Int										andDataValue: aString asNumber ).								]								ifFalse: [									"Chequea si empieza con T# o TIME# para parsear el numero como TIME"									( ( aString asUppercase beginsWith: 'T#' ) or: 									[ aString asUppercase beginsWith: 'TIME#'  ] )										ifTrue: [ 											"Si era numero creo un Literal TIME"											argument := ( PLC_Literal 												newWithDataType: PLC_DataType Time												andDataValue: aString extractNumber ).										] 										ifFalse: [ 											"NO PUDE PARSEARLO" 																						"INVENTO UNA DECLARACION DE VARIABLE"											"varDecl := PLC_SymbolicVariableDecl 												newWithDataType: PLC_DataType Void												andInitialValue: nil 												andIdentifier: aString."																			"Creo el Operando Variable a partir de la Declaración de Variable"											"argument := PLC_Variable 												newWithDeclaration: varDecl 												andDataValue: nil."											"Creo un VoidOperand"												argument := PLC_ErrorOpenad new.											argument dataValue: aString.																						"Aviso en pantalla que no encontre la variable. 											ESTA MUY MAL ACA ESTO, DEBERIA HACERLO 											LA VISTA"											GrowlMorph 												openWithLabel: 'Error' 												contents: 'Variable no encontrada entre las declaraciones o valor inválido'.																					].								]. 						]. 				].		]		ifNotNil: [			"Encontro declaracion, creo un nuevo Operando variable 			con la declaración hallada"			argument := PLC_Variable 				newWithDeclaration: decl 				andDataValue: decl initialValue.		].			^ argument.! !!PLC_ConnectableBlocksNetwork methodsFor: 'PARSER' stamp: 'CarlosLombardi 9/22/2016 11:33'!parse: aString	"parse an operand into a PLC_Literal or PLC_Variable.	 If aString is an invalid operand, then a PLC_ErrorOpenad is returned. 	 In this case, an error message is also shown (shame!! for not delegating the message display to GUI components). "		| pouDecls variableParser operandParser result errorText |		pouDecls := self pouBody pou declarations.		variableParser := IDE4PLCParsers idParser ==> [ :idString |		| decl |		decl := pouDecls includeVarDeclWithIdentifier: aString.		decl ifNil: [				PLC_ErrorOpenad new dataValue: idString ; yourself			] ifNotNil: [ 				"Encontro declaracion, creo un nuevo Operando variable 				con la declaración hallada"				PLC_Variable 					newWithDeclaration: decl 					andDataValue: decl initialValue.			]	] .		operandParser := 		IDE4PLCParsers literalBOOLParser /			IDE4PLCParsers literalINTParser /		IDE4PLCParsers literalREALParser /		IDE4PLCParsers literalTIMEParser /		variableParser .		result := operandParser parse: aString.		errorText := nil .	"lexing error, I give different message but return similar error operand"		result isPetitFailure ifTrue: [ 		errorText := 'Valor inválido'.				result := PLC_ErrorOpenad new dataValue: aString ; yourself .	] ifFalse: [ 		"lexing OK, unknown identifier"			result isError ifTrue: [ 			errorText := 'Variable no encontrada entre las declaraciones'.				] .	] .		errorText ifNotNil: [ 		"Aviso en pantalla que no encontre la variable. 		 ESTA MUY MAL ACA ESTO, DEBERIA HACERLO LA VISTA"		GrowlMorph openWithLabel: 'Error' contents: errorText .			] .		^result! !!IDE4PLCParsers class methodsFor: 'as yet unclassified' stamp: 'CarlosLombardi 9/22/2016 11:11'!literalREALParser	"a parser for a REAL literal.		(REAL#)?real "	| realType realLiteral |	realType := 'REAL#' asParser.	realLiteral := (realType optional , BasicParsers realNumber) end ==> [ :nodes | 		PLC_Literal			newWithDataType: PLC_DataType Real				andDataValue: nodes second 	] .	^realLiteral! !!IDE4PLCParsers class methodsFor: 'as yet unclassified' stamp: 'CarlosLombardi 9/22/2016 00:54'!literalBOOLParser	"a parser for a BOOL literal.		(BOOL#)?(true|false) "	| trueOrFalse boolType boolLiteral |	trueOrFalse := ('true' asParser ==> [:str | true]) / ('false' asParser  ==> [:str | false]).	boolType := 'BOOL#' asParser.	boolLiteral := (boolType optional , trueOrFalse) end ==> [ :nodes | 		PLC_Literal 						newWithDataType: PLC_DataType Bool						andDataValue: nodes second	] .	^boolLiteral! !!IDE4PLCParsers class methodsFor: 'as yet unclassified' stamp: 'CarlosLombardi 9/22/2016 01:14'!literalTIMEParser	"a parser for a TIME literal.		(TIME|T)#uinteger "	| timeType timeLiteral |	timeType := 'TIME#' asParser / 'T#' asParser.	timeLiteral := (timeType, BasicParsers naturalNumber) end ==> [ :nodes | 		PLC_Literal			newWithDataType: PLC_DataType Time			andDataValue: nodes second 	] .	^timeLiteral! !!IDE4PLCParsers class methodsFor: 'as yet unclassified' stamp: 'CarlosLombardi 9/22/2016 00:56'!literalINTParser	"a parser for a INT literal, understood as signed integer.		(INT#)?integer "	| intType intLiteral |	intType := 'INT#' asParser.	intLiteral := (intType optional , BasicParsers naturalNumber) end ==> [ :nodes | 		PLC_Literal			newWithDataType: PLC_DataType Int				andDataValue: nodes second 	] .	^intLiteral	! !!IDE4PLCParsers class methodsFor: 'as yet unclassified' stamp: 'CarlosLombardi 9/22/2016 10:10'!idParser	"a parser for an identifier.		(letter | _) (letter | _ | digit)*"	| firstLetter subsequentLetters |	firstLetter := #letter asParser / $_ asParser .	subsequentLetters := #letter asParser / $_ asParser / #digit asParser.	^(firstLetter, subsequentLetters star) end flatten .		! !!BasicParsers class methodsFor: 'numbers' stamp: 'CarlosLombardi 9/13/2016 09:21'!integerNumber	"a parser for a signed integer number"	^(self optionalSign, self naturalNumber)  ==> 		[ :nodes | nodes first value: nodes second ].! !!BasicParsers class methodsFor: 'numbers' stamp: 'CarlosLombardi 9/13/2016 02:18'!naturalNumber	"a parser for a natural number"	^#digit asParser plus flatten ==> [:str | str asNumber]! !!BasicParsers class methodsFor: 'numbers' stamp: 'CarlosLombardi 9/13/2016 09:18'!decimalPart	"a parser for the decimal part of a number"	^($. asParser, self naturalNumber) ==>	[ :nodes | ('0.', nodes second asString) asNumber. ]! !!BasicParsers class methodsFor: 'numbers' stamp: 'CarlosLombardi 9/22/2016 11:17'!realNumber	"a parser for a real number. Scientific notation to be done"	| positiveRealWithIntegerPart positiveReal |	positiveRealWithIntegerPart := 		(self integerNumber, self decimalPart optional) ==>		[ :nodes | nodes first + (nodes second ifNil: [0]) ] .	positiveReal := positiveRealWithIntegerPart / self decimalPart .	^(self optionalSign, positiveReal)  ==> 	[ :nodes | (nodes first value: nodes second) asFloat ].! !!BasicParsers class methodsFor: 'numbers' stamp: 'CarlosLombardi 9/13/2016 02:18'!optionalSign	"a parser for an optional sign, e.g. the minus sign in -4349.21"	^$- asParser optional ==> [:charOrNil | 	charOrNil 		ifNil: [ [:n | n] ] ifNotNil: [ [:n | n negated] ]	]! !!BasicParsers class reorganize!(#numbers integerNumber naturalNumber decimalPart realNumber optionalSign)!IDE4PLCParsers class removeSelector: #literalFLOATParser!